use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use flate2::Compression;
use flate2::GzBuilder;
use walkdir::WalkDir;

#[derive(Debug)]
struct BlobData {
    hash: [u8; 32],
    gzip: Vec<u8>,
    raw_len: u32,
}

#[derive(Debug, Clone)]
struct TemplateAsset {
    path: String,
    hash: [u8; 32],
}

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("manifest dir"));
    let assets_root = manifest_dir.join("assets");
    let templates_root = assets_root.join("templates");
    let shared_root = assets_root.join("shared");

    let mut template_assets: BTreeMap<String, Vec<TemplateAsset>> = BTreeMap::new();
    let mut blobs: BTreeMap<[u8; 32], BlobData> = BTreeMap::new();

    if templates_root.exists() {
        let mut template_dirs = list_dirs_sorted(&templates_root);
        template_dirs.sort();
        for template_dir in template_dirs {
            let name = template_dir
                .file_name()
                .and_then(|value| value.to_str())
                .unwrap_or("")
                .to_string();
            if name.is_empty() {
                continue;
            }
            let assets = collect_assets(&template_dir, &template_dir);
            for asset in assets {
                let hash = blake3::hash(&asset.bytes);
                let hash_bytes = *hash.as_bytes();
                let entry = TemplateAsset {
                    path: asset.rel_path,
                    hash: hash_bytes,
                };
                template_assets.entry(name.clone()).or_default().push(entry);
                blobs.entry(hash_bytes).or_insert_with(|| BlobData {
                    hash: hash_bytes,
                    gzip: gzip_bytes(&asset.bytes),
                    raw_len: asset.bytes.len() as u32,
                });
            }
        }
    }

    if shared_root.exists() {
        let assets = collect_assets(&shared_root, &shared_root);
        for asset in assets {
            let hash = blake3::hash(&asset.bytes);
            let hash_bytes = *hash.as_bytes();
            let entry = TemplateAsset {
                path: asset.rel_path,
                hash: hash_bytes,
            };
            template_assets
                .entry("shared".to_string())
                .or_default()
                .push(entry);
            blobs.entry(hash_bytes).or_insert_with(|| BlobData {
                hash: hash_bytes,
                gzip: gzip_bytes(&asset.bytes),
                raw_len: asset.bytes.len() as u32,
            });
        }
    }

    let out_path = manifest_dir.join("src").join("generated.rs");
    let contents = render_generated(&template_assets, &blobs);
    fs::write(&out_path, contents).expect("write generated.rs");

    println!("cargo:rerun-if-changed=assets");
}

struct RawAsset {
    rel_path: String,
    bytes: Vec<u8>,
}

fn collect_assets(root: &Path, base: &Path) -> Vec<RawAsset> {
    let mut paths: Vec<PathBuf> = WalkDir::new(root)
        .follow_links(false)
        .into_iter()
        .filter_map(|entry| entry.ok())
        .filter(|entry| entry.file_type().is_file())
        .map(|entry| entry.path().to_path_buf())
        .collect();
    paths.sort_by(|a, b| rel_string(a, base).cmp(&rel_string(b, base)));

    paths
        .into_iter()
        .map(|path| {
            let rel = rel_string(&path, base);
            let bytes = fs::read(&path).expect("read asset");
            RawAsset {
                rel_path: rel,
                bytes,
            }
        })
        .collect()
}

fn rel_string(path: &Path, base: &Path) -> String {
    path.strip_prefix(base)
        .unwrap_or(path)
        .to_string_lossy()
        .replace('\\', "/")
}

fn list_dirs_sorted(root: &Path) -> Vec<PathBuf> {
    let mut dirs = Vec::new();
    if let Ok(entries) = fs::read_dir(root) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                dirs.push(path);
            }
        }
    }
    dirs.sort();
    dirs
}

fn gzip_bytes(raw: &[u8]) -> Vec<u8> {
    let mut encoder = GzBuilder::new()
        .mtime(0)
        .write(Vec::new(), Compression::default());
    encoder.write_all(raw).expect("gzip write");
    encoder.finish().expect("gzip finish")
}

fn render_generated(
    templates: &BTreeMap<String, Vec<TemplateAsset>>,
    blobs: &BTreeMap<[u8; 32], BlobData>,
) -> String {
    let mut out = String::new();
    let mut template_assets_src = String::new();
    out.push_str("// @generated by build.rs\n");
    out.push_str("use super::{AssetEntry, Blob, Template};\n\n");

    out.push_str("pub static BLOBS: &[Blob] = &[\n");
    for blob in blobs.values() {
        out.push_str("    Blob { hash: ");
        out.push_str(&format_array(&blob.hash));
        out.push_str(", gzip: ");
        out.push_str(&format_slice(&blob.gzip));
        out.push_str(&format!(", raw_len: {} }},\n", blob.raw_len));
    }
    out.push_str("];\n\n");

    let mut template_names = Vec::new();
    for name in templates.keys() {
        template_names.push(name.clone());
    }
    template_names.sort();

    out.push_str("pub static TEMPLATE_NAMES: &[&str] = &[\n");
    for name in &template_names {
        out.push_str(&format!("    \"{}\",\n", name));
    }
    out.push_str("];\n\n");

    for name in &template_names {
        if let Some(entries) = templates.get(name) {
            let mut sorted_entries = entries.clone();
            sorted_entries.sort_by(|a, b| a.path.cmp(&b.path));
            let ident = format!("TEMPLATE_{}", sanitize_ident(name));
            template_assets_src.push_str(&format!("static {}: &[AssetEntry] = &[\n", ident));
            for entry in &sorted_entries {
                template_assets_src.push_str("    AssetEntry { path: \"");
                template_assets_src.push_str(&entry.path);
                template_assets_src.push_str("\", hash: ");
                template_assets_src.push_str(&format_array(&entry.hash));
                template_assets_src.push_str(" },\n");
            }
            template_assets_src.push_str("];\n\n");
        }
    }
    out.push_str(&template_assets_src);

    out.push_str("pub static TEMPLATES: &[Template] = &[\n");
    for name in &template_names {
        if templates.contains_key(name) {
            let ident = format!("TEMPLATE_{}", sanitize_ident(name));
            out.push_str(&format!(
                "    Template {{ name: \"{}\", assets: &{} }},\n",
                name, ident
            ));
        }
    }
    out.push_str("];\n");
    out
}

fn sanitize_ident(name: &str) -> String {
    let mut out = String::new();
    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        out.push_str("TEMPLATE");
    }
    out
}

fn format_array(bytes: &[u8]) -> String {
    let mut out = String::new();
    out.push('[');
    for (idx, byte) in bytes.iter().enumerate() {
        if idx % 16 == 0 {
            out.push_str("\n        ");
        }
        out.push_str(&format!("0x{:02X}, ", byte));
    }
    if !bytes.is_empty() {
        out.push('\n');
        out.push_str("    ");
    }
    out.push(']');
    out
}

fn format_slice(bytes: &[u8]) -> String {
    let mut out = String::new();
    out.push_str("&");
    out.push_str(&format_array(bytes));
    out
}
