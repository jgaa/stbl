use stbl_core::assets::AssetManifest;
use stbl_core::config::load_site_config;
use stbl_core::header::Header;
use stbl_core::model::{DocId, Page, Project, SiteContent};
use stbl_core::templates::{
    BlogIndexItem, SeriesIndexPart, SeriesNavLink, SeriesNavView, TagListingPage,
    render_blog_index, render_page, render_page_with_series_nav, render_series_index,
    render_tag_index,
};
use std::fs;
use std::path::PathBuf;
use uuid::Uuid;

const BUILD_DATE: &str = "2026-01-25";

#[test]
fn envelope_blog_index_has_chrome_regions_and_single_h1() {
    let (project, site_title) = project_with_config(default_config());
    let item = simple_item();
    let html = render_blog_index(
        &project,
        "Blog".to_string(),
        None,
        None,
        vec![item],
        None,
        None,
        1,
        1,
        &default_manifest(),
        "index.html",
        BUILD_DATE,
    )
    .expect("render blog index");

    assert_envelope(&html, &site_title);
    assert!(html.contains(&format!("<title>Blog · {site_title}</title>")));
}

#[test]
fn envelope_article_has_chrome_regions_and_single_h1() {
    let (project, site_title) = project_with_config(default_config());
    let page = simple_page("Article One", "articles/page1.md");
    let html = render_page(
        &project,
        &page,
        &default_manifest(),
        "page1.html",
        BUILD_DATE,
    )
    .expect("render page");

    assert_envelope(&html, &site_title);
    assert!(html.contains(&format!("<title>Article One · {site_title}</title>")));
}

#[test]
fn envelope_tag_page_has_chrome_regions_and_single_h1() {
    let (project, site_title) = project_with_config(default_config());
    let listing = TagListingPage {
        tag: "rust".to_string(),
        items: vec![simple_item()],
    };
    let html = render_tag_index(
        &project,
        listing,
        &default_manifest(),
        "tags/rust.html",
        BUILD_DATE,
    )
    .expect("render tag index");

    assert_envelope(&html, &site_title);
    assert!(html.contains(&format!("<title>Tag: rust · {site_title}</title>")));
}

#[test]
fn envelope_series_index_has_chrome_regions_and_single_h1() {
    let (project, site_title) = project_with_config(default_config());
    let index = simple_page("Series Alpha", "articles/series/index.md");
    let parts = vec![SeriesIndexPart {
        title: "Part 1".to_string(),
        href: "series/part1.html".to_string(),
        published_display: Some("2024-01-01".to_string()),
    }];
    let html = render_series_index(
        &project,
        &index,
        parts,
        &default_manifest(),
        "series.html",
        BUILD_DATE,
    )
    .expect("render series index");

    assert_envelope(&html, &site_title);
    assert!(html.contains(&format!("<title>Series Alpha · {site_title}</title>")));
}

#[test]
fn envelope_series_part_has_chrome_regions_and_single_h1() {
    let (project, site_title) = project_with_config(default_config());
    let page = simple_page("Series Part", "articles/series/part1.md");
    let nav = SeriesNavView {
        prev: None,
        index: SeriesNavLink {
            title: "Series Alpha".to_string(),
            href: "series.html".to_string(),
        },
        next: Some(SeriesNavLink {
            title: "Part 2".to_string(),
            href: "series/part2.html".to_string(),
        }),
    };
    let html = render_page_with_series_nav(
        &project,
        &page,
        &default_manifest(),
        Some(nav),
        "part1.html",
        BUILD_DATE,
    )
    .expect("render series part");

    assert_envelope(&html, &site_title);
    assert!(html.contains(&format!("<title>Series Part · {site_title}</title>")));
}

#[test]
fn footer_show_stbl_toggle_controls_generator_stamp() {
    let (project, _) = project_with_config(default_config());
    let page = simple_page("Footer", "articles/footer.md");
    let html = render_page(
        &project,
        &page,
        &default_manifest(),
        "footer.html",
        BUILD_DATE,
    )
    .expect("render page");
    assert!(html.contains("Generated by"));
    assert!(html.contains("<a href=\"https://github.com/jgaa/stbl\">stbl</a>"));
    assert!(html.contains("on 2026-01-25"));

    let (project, _) = project_with_config(config_without_stbl());
    let html = render_page(
        &project,
        &page,
        &default_manifest(),
        "footer.html",
        BUILD_DATE,
    )
    .expect("render page");
    assert!(!html.contains("Generated by"));
    assert!(html.contains("<footer>"));
}

fn assert_envelope(html: &str, site_title: &str) {
    assert!(html.contains("<header"));
    assert!(html.contains("<main>"));
    assert!(html.contains("<footer>"));
    assert!(html.contains("<nav aria-label=\"Primary\""));
    assert_eq!(count_substr(html, "<h1"), 1);
    assert!(html.contains("<title>"));
    assert!(html.contains(&format!("· {site_title}</title>")));
}

fn count_substr(haystack: &str, needle: &str) -> usize {
    haystack.match_indices(needle).count()
}

fn project_with_config(config: &str) -> (Project, String) {
    let path = write_temp_config(config);
    let config = load_site_config(&path).expect("config");
    let site_title = config.site.title.clone();
    (
        Project {
            root: PathBuf::from("."),
            config,
            content: SiteContent::default(),
            image_alpha: std::collections::BTreeMap::new(),
            image_variants: Default::default(),
            video_variants: Default::default(),
        },
        site_title,
    )
}

fn write_temp_config(contents: &str) -> PathBuf {
    let path = std::env::temp_dir().join(format!("stbl-envelope-{}.yaml", Uuid::new_v4()));
    fs::write(&path, contents).expect("write config");
    path
}

fn default_config() -> &'static str {
    "site:\n  id: \"demo\"\n  title: \"Site One\"\n  base_url: \"https://example.com/\"\n  language: \"en\"\n"
}

fn config_without_stbl() -> &'static str {
    "site:\n  id: \"demo\"\n  title: \"Site One\"\n  base_url: \"https://example.com/\"\n  language: \"en\"\nfooter:\n  show_stbl: false\n"
}

fn simple_item() -> BlogIndexItem {
    BlogIndexItem {
        title: "Item".to_string(),
        href: "item.html".to_string(),
        published_display: Some("2024-01-01".to_string()),
        updated_display: None,
        kind_label: None,
        abstract_text: None,
        tags: Vec::new(),
        latest_parts: Vec::new(),
    }
}

fn simple_page(title: &str, source_path: &str) -> Page {
    let mut header = Header::default();
    header.title = Some(title.to_string());
    Page {
        id: DocId(blake3::hash(source_path.as_bytes())),
        source_path: source_path.to_string(),
        header,
        body_markdown: "Body".to_string(),
        banner_name: None,
        media_refs: Vec::new(),
        url_path: "simple".to_string(),
        content_hash: blake3::hash(source_path.as_bytes()),
    }
}

fn default_manifest() -> AssetManifest {
    let mut entries = std::collections::BTreeMap::new();
    entries.insert(
        "css/vars.css".to_string(),
        "artifacts/css/vars.css".to_string(),
    );
    entries.insert(
        "css/common.css".to_string(),
        "artifacts/css/common.css".to_string(),
    );
    entries.insert(
        "css/desktop.css".to_string(),
        "artifacts/css/desktop.css".to_string(),
    );
    entries.insert(
        "css/mobile.css".to_string(),
        "artifacts/css/mobile.css".to_string(),
    );
    entries.insert(
        "css/wide-desktop.css".to_string(),
        "artifacts/css/wide-desktop.css".to_string(),
    );
    AssetManifest { entries }
}
